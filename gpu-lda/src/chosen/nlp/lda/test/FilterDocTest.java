package chosen.nlp.lda.test;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.Map.Entry;
import java.util.StringTokenizer;

import chosen.nlp.lda.conf.PathConfig;
import common.IDUtil;
import chosen.social.lda.util.Link;
import common.TwitterIDUtil;

public class FilterDocTest {
    
    public static double ration = 0;
    public static int filterBehind = 10;  //删除followerMapSize小于10的follower和followee
    private static Scanner scaner;
    
    public static void main(String args []) throws ClassNotFoundException {
        
    // path for save follower & ee doc
    // arg[0] = 1, we use the wb.ds firstly, then the 2nd time arg[1] = 0, we choose the keeptext.txt, which is generated by the above step.
    try {
        scaner = new Scanner(System.in);
        System.out.println("split Files into ");
        ration = Double.parseDouble(args[1]);
        String path;
        System.out.println("seperator");
        String seperator = "\t|,";   //分隔符是tab或者逗号
        
           //第一次传1， 读wb.ds的内容，生成keepdata.txt, testdata.txt和follower文件夹下的内容。
        //第二次传0， 读取keepdata.txt的内容, 生成followee文件中的内容
        if(args[0].equals("0"))   
            path = PathConfig.keepDataPath;
        else
            path = PathConfig.twitterUserLinksFile;
      
        BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(path)));
        StringBuffer fileData = new StringBuffer();
        int bufferSize = 1024 * 1024;   //buffersize = 1MB
        char[] buffer = new char[bufferSize];
        int numRead = 0;   //numbers of characters read.
        int count = 0;     //
        int transferTimes = 0;
        String lastLine = "";  //append a empty line after the last link.
      
        try {
            //success to read buffer from bufferReader, and store the numbers of read links in numRead.
            while ((numRead = bufferedReader.read(buffer)) != -1) {
                String readData = String.valueOf(buffer, 0, numRead);
                readData = readData.replaceAll(seperator, " "); //使用空格替代制表符和逗号
                fileData.append(readData);
                if(++transferTimes % 100 == 0 )  //每append一次，一次1M的内容
                    System.out.println( (++transferTimes) + " M block has been loaded in");
                if (++count >= 1000) {
                    // 每读1000次写一次文档  
                    lastLine = "";
                    writeToDocuments(fileData, lastLine , args[0]);

                    // append not read last line to file
                    fileData = new StringBuffer();
                    fileData.append(lastLine);
                    count = 0;
                    System.gc();
                }
            }
            //写入剩余部分 
            writeToDocuments(fileData, lastLine, args[0]); 
        } catch (IOException e) {
            e.printStackTrace();
        }
        bufferedReader.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 将filedata中的数据先存入link中，再从link中分别取出follower和followee加入到follower(e)_Map中
    public static void writeToDocuments(StringBuffer fileData, String lastLine , String arg) throws IOException, ClassNotFoundException {
        Map<Integer, ArrayList<Integer>> follower_Map; //每个人的index对应一个他的关注者index的List
        Map<Integer, ArrayList<Integer>> followee_Map; //每个人的index对应着 关注他的人的index的 List
        ArrayList<Link> links = new ArrayList<Link>();

        //读取keepdata.txt中的内容
        if (arg.equals("0")) {
            IDUtil idUtil = new IDUtil();
            idUtil = idUtil.read();
            TwitterIDUtil.IDToIndexMap = idUtil.IDToIndexMap;
            TwitterIDUtil.indexToIDMap = idUtil.indexToIDMap;
        }
        
        //tokenizedToLinkAndgetLastLine(String dataString, ArrayList<Link> links, char spliter, String lastLine) 
        tokenizedToLinkAndgetLastLine(fileData.toString(), links, ',' ,lastLine);  // ',' is the split, not used here
    
        follower_Map = new HashMap <Integer, ArrayList<Integer>>();
        followee_Map = new HashMap <Integer, ArrayList<Integer>>();
        
        int times = 0;
        //遍历links：ArrayList中的节点
        for(Link twitterLink : links) {
            if(++times % 100000 == 0)
                System.out.println(times + "links ");
            //follower粉丝            followee 关注对象 
            addToLinkListMap(follower_Map, twitterLink.follower, twitterLink.followee);
            addToLinkListMap(followee_Map, twitterLink.followee, twitterLink.follower);
        }
    
        links.clear();
        links = null;
        System.gc();
    
        if (!arg.equals("0")) {
            //integer limit = 200;
            //entrySet(): return a Set view of mappings contained in the Map. It returns a collection view of the map
            //iterator(): return an iterator over the elements in the set.
            //A map entry is in fact a key-value pair.
            //Iterator takes place of Enumeration in Java Collection Framework.
            Iterator<Entry<Integer, ArrayList<Integer>>> it = follower_Map.entrySet().iterator();
            //hasNext(): return true if the iterator has more emelemts.
            while (it.hasNext()) {
                Entry<Integer, ArrayList<Integer>> followerEntry = it.next();
                //getKey(): return the key corresponding to this entry.
                int key = followerEntry.getKey();
                
                //Math.random(): return a double value with a positive sign between 1.0 - 0.0
                double cursor = Math.random() * ration ;
                if (cursor < ration - 1) { //followeeSize < limit || followerSize < limit
                    it.remove();
                    followee_Map.remove(key);
                }
            }
            
            Iterator<Entry<Integer,ArrayList<Integer>>> eeIterator = followee_Map.entrySet().iterator();
            //remove those followees that are not followers,除去那些没有关注任何人的followee
            while(eeIterator.hasNext()) {
                Entry<Integer, ArrayList<Integer>> followeeEntry = eeIterator.next();
                int key = followeeEntry.getKey();
                if(!follower_Map.containsKey(key)) {
                    eeIterator.remove();
                }
            }
            
            // 
            recursiveRemove(filterBehind, follower_Map, followee_Map);
            
            //清除之前跑程序遗留下的txt 
            clearExistDocs(PathConfig.followerPath,PathConfig.followeePath);
      
            // 输出文档 , 注意文档名为id ,实际内容也为id
            // 文档分为两个文件夹 follower 和 followee
            ShuffleListToDocuments(follower_Map, followee_Map, PathConfig.followerPath);
            
            //Map.clear(): clear all the mappings from the map.
            follower_Map.clear();
            follower_Map = null;
            System.gc();
            
            IDUtil idUtil = new IDUtil();
            idUtil.IDToIndexMap = TwitterIDUtil.IDToIndexMap;
            idUtil.indexToIDMap = TwitterIDUtil.indexToIDMap;
            idUtil.write();
            
        } else {
            //第二次写入/followees
            listToDocuments(followee_Map, PathConfig.followeePath);
            followee_Map.clear();    
            followee_Map = null;
            System.gc();
        }
        //listToDocuments(follower_Map, followee_Map, PathConfig.allFollowPathString);
    }

    private static void recursiveRemove (int limit , Map<Integer, ArrayList<Integer>> follower_Map , Map<Integer, ArrayList<Integer>> followee_Map) {
        
        boolean flag = true;
        // used to store a follower's followeeList's size, or number of elements in the followeeList
        int followerSizeMap[] = new int[TwitterIDUtil.getSize()];
        int followeeSizeMap[] = new int[TwitterIDUtil.getSize()];
    
        Iterator<Entry<Integer, ArrayList<Integer>>> it = follower_Map.entrySet().iterator();
        while (it.hasNext()) {
            Entry<Integer, ArrayList<Integer>> followerEntry = it.next();
            int key = followerEntry.getKey();
            int followeeSize = 0;
            //if the follower-key is also in the followee map, update the followeeSizeMap at the same time.
            if (followee_Map.containsKey(key)) {
                //followeeSize is the number of elements in the follower's followeeList.
                followeeSize = followee_Map.get(key).size();
                followeeSizeMap[key] = followeeSize;
            }
            int followerSize = followerEntry.getValue().size();
            followerSizeMap[key] = followerSize;
        }
        while(flag == true) {
            flag = false;
            Iterator<Entry<Integer, ArrayList<Integer>>> it_rm = follower_Map.entrySet().iterator();
            //delete the followeeSize < limit or followerSize < limit 's 
            while (it_rm.hasNext()) {
                Entry<Integer, ArrayList<Integer>> followerEntry = it_rm.next();
                int key = followerEntry.getKey();
                int followeeSize = followeeSizeMap[key];
                int followerSize = followerSizeMap[key];
                if ( followerSize < limit && followeeSize < limit ) { //followeeSize < limit || followerSize < limit
                    it_rm.remove();
                    followeeSizeMap[key] = 0;
                    followerSizeMap[key] = 0;
                    if(followee_Map.containsKey(key)) 
                        for(int erId : followee_Map.get(key)) {
                            followerSizeMap[erId]--;
                        }
                    followee_Map.remove(key);
                    flag = true;
                }
            }
        }
    }
  
    private static void clearExistDocs(String followerPath, String followeePath) {
        File followerdir = new File(followerPath);
        File followeedir = new File (followeePath);
        //File.listFiles(): returns an array of abstract pathnames denoting the files 
        //in the directory denoted by this abstract name.
        if (followerdir.listFiles() != null) {
            for (File file : followerdir.listFiles()) {
                file.delete();
            }
        }
        if (followeedir.listFiles() != null) {
            for (File file : followeedir.listFiles()) {
                file.delete();
            }
        }
    }

    public static void ShuffleListToDocuments(
            Map<Integer, ArrayList<Integer>> follower_Map, 
            Map<Integer, ArrayList<Integer>> followee_Map, 
            String path) throws IOException 
    {
        BufferedWriter bufferedWriter = null;
        //configure test dataset's file path.
        String testDataPath = PathConfig.testDataPath;
        BufferedWriter testDataBufferedWriter = new BufferedWriter(new FileWriter(testDataPath));
        //keepDataSet is the train dataset.
        BufferedWriter keepDataBufferedWriter = new BufferedWriter(new FileWriter(PathConfig.keepDataPath));
        
        int times = 0 ;
        
        //follower's index --> followee's index list.(an element)
        for(Entry<Integer, ArrayList<Integer>> followEntry : follower_Map.entrySet()) {
            if(++times % 10000 == 0)
                System.out.println(times + "links ok.");
            //path + 'follower's ID.txt', not follower's index.
            String filePath = path + Link.getLinkeeVaule(followEntry.getKey()) + ".txt";
            //Constructs a FileWriter object given a file name :  filePath
            //with a boolean indicating whether or not to append the data written.: ture means append the data written.
            bufferedWriter =new BufferedWriter(new FileWriter(filePath, true) );
            //shuffle , make down split point ,save to a different doc.
            ArrayList<Integer> shuffleList = followEntry.getValue();
            //Collections.shuffle(): Randomly permute the specified list using a default source of randomness.
            Collections.shuffle(shuffleList);
            int crossOverRemark = shuffleList.size() / 10;  //leave 10% for test dataset.
            //int crossOverRemark = 0;
            for(int i = 0 ; i < crossOverRemark ; i++) {
                Integer index = shuffleList.get(i);
                if(followee_Map.containsKey(index))
                    //content format: 'followerID followeeID\n'
                    testDataBufferedWriter.append(Link.getLinkeeVaule(followEntry.getKey()) + " " + Link.getLinkeeVaule(index) + "\n");
            }
            
            //write the rest 90% to train dataset
            for (int i = crossOverRemark; i < shuffleList.size(); i++) {
                Integer index = shuffleList.get(i);
                if(followee_Map.containsKey(index)) {
                    //write every entry to *.txt in /follower(e)s
                    bufferedWriter.append(Link.getLinkeeVaule(index) + " ");
                    //write to testdata.txt
                    keepDataBufferedWriter.append(Link.getLinkeeVaule(followEntry.getKey()) + " " + Link.getLinkeeVaule(index) + "\n");
                }
            }
            bufferedWriter.close();
        }
        testDataBufferedWriter.close();
        keepDataBufferedWriter.close();
    }

    public static void listToDocuments(Map<Integer, ArrayList<Integer>> followee_Map, String path) throws IOException {
        
        BufferedWriter bufferedWriter = null;
        int times = 0 ;
        for(Entry<Integer, ArrayList<Integer> > followEntry : followee_Map.entrySet()) {
            if(++times % 10000 == 0) {
                System.out.println(times + "links ok.");
            }
      
            String filePath = path + Link.getLinkeeVaule(followEntry.getKey()) + ".txt";
            bufferedWriter =new BufferedWriter(new FileWriter(filePath, true) );
            //shuffle , make down split point ,save to a different doc.
            ArrayList<Integer> followValueList = followEntry.getValue();
     
            for (int i = 0 ; i < followValueList.size(); i++) {
                Integer index = followValueList.get(i);
                bufferedWriter.append(Link.getLinkeeVaule(index) + " ");
            }
            bufferedWriter.close();
        }
    }
  
    public static void listToDocuments(
            Map<Integer, ArrayList<Integer>> follower_Map, 
              Map<Integer, ArrayList<Integer>> followee_Map,String path) {
        
        BufferedWriter bufferedWriter = null;
          int times = 0 ;
          for(Entry<Integer, ArrayList<Integer> > followEntry : follower_Map.entrySet()) {
              if(++times % 10000 == 0) {
                  System.out.println(times + "links ok.");
              }
                  
              try {
                  String filePath = path + Link.getLinkeeVaule(followEntry.getKey()) + ".txt";
                  bufferedWriter =new BufferedWriter(new FileWriter(filePath, true) );
                      
                  //listToDocuments
                  HashSet<Integer> unionSet = new HashSet<Integer>();
                  //Adds all of the elements in the specified collection to this collection
                  unionSet.addAll(followEntry.getValue());
                  if(followee_Map.containsKey(followEntry.getKey())){
                      ArrayList<Integer> followeeList= followee_Map.get(followEntry.getKey());
                      unionSet.addAll(followeeList);
                  }
        
                  for(Integer index : unionSet) {
                      bufferedWriter.append(Link.getLinkeeVaule(index) + " ");
                  }
                  bufferedWriter.close();
        
              } catch (IOException e) {
                  // exception handling left as an exercise for the reader
              }
          }
      }

      
      public static void addToLinkListMap(Map<Integer, ArrayList<Integer>> follow_Map, int executor, int target) {
          ArrayList<Integer> followList;
          if (!follow_Map.containsKey(executor) ) {
              followList = new ArrayList<Integer>();
              followList.add(target);
              follow_Map.put(executor, followList);
          } else {
              followList = follow_Map.get(executor);
              followList.add(target);
          }
      }

      public static void tokenizedToLinkAndgetLastLine(String dataString, ArrayList<Link> links, char spliter, String lastLine) {
          //StringTokenizer allow break a string into tokens.
        StringTokenizer strTok = new StringTokenizer(dataString);
        while (strTok.hasMoreTokens()) {
            String token_follower = strTok.nextToken();
            if( strTok.hasMoreTokens() ) {
              String token_followee = strTok.nextToken();
              links.add( new Link(token_follower,token_followee) );
            } else {
              //get the last line 
              lastLine = token_follower;
            }
        }
        
        if (lastLine.length() > 0) {
            //get the last line
            Link link = links.get(links.size()-1);
            lastLine = Link.getLinkeeVaule(link.follower) +" "+Link.getLinkeeVaule(link.follower);
            links.remove(links.size()-1);
        }
    }
  
}
